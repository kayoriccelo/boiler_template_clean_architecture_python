import json
import sys
from http.client import INTERNAL_SERVER_ERROR, OK
from typing import Tuple

from src.core.exceptions import (
    RepositoryException, UseCaseRuleException, UseCaseBusinessException, ValidatorException
)
from src.core.messages import INCONSISTENCY_MESSAGE_FOUND, INCONSISTENCY_MESSAGE_FOUND_SYSTEM


class BaseController:
    business_class = None
    persenter_class = None
    
    def __init__(self, repository: object, serializer_class: object):
        self.business = self.business_class(repository)
        self.presenter = self.persenter_class(serializer_class)

    def _send_email_error(self, exception: Exception):
        exc_type, exc_value, exc_traceback = sys.exc_info()
        trace = exception.__traceback__

        # TODO - Kayo: simulate sending email.
        print(f"""
            *****************************************************
            
            WARNING: Exception generated by the system.

            type               : {exc_type.__name__}
            message            : {exc_value.message if hasattr(exc_value, 'message') else ''}
            error              : {exc_value.error if hasattr(exc_value, 'error') else ''}
            tracking lines     : 
        """)

        while trace is not None:
            print(f"""
                -------------------------------------------------  
                ---> path and file name : {trace.tb_frame.f_code.co_filename}
                ---> line code          : {trace.tb_lineno}
                ---> method name        : {trace.tb_frame.f_code.co_name}
                -------------------------------------------------
            """)

            trace = trace.tb_next

        print(f"""
            *****************************************************
        """)

    def _to_try(self, callback):
        try:
            payload = callback()

        except ValidatorException as err:
            return {'type': 'validator', 'message': err.message, 'errors': err.errors}, INTERNAL_SERVER_ERROR.value
        
        except UseCaseRuleException as err:
            return {'type': 'rule', 'message': err.message}, INTERNAL_SERVER_ERROR.value
               
        except UseCaseBusinessException as err:
            self._send_email_error(err)
            
            return {'type': 'business', 'message': INCONSISTENCY_MESSAGE_FOUND % err.message}, INTERNAL_SERVER_ERROR.value

        except RepositoryException as err:
            self._send_email_error(err)
            
            return {'type': 'repository', 'message': INCONSISTENCY_MESSAGE_FOUND_SYSTEM}, INTERNAL_SERVER_ERROR.value

        except Exception as err:
            self._send_email_error(err)
            
            return {'type': 'generic', 'message': INCONSISTENCY_MESSAGE_FOUND_SYSTEM}, INTERNAL_SERVER_ERROR.value
        
        return payload, OK.value

    def get(self, pk: int) -> Tuple[dict, int]:
        def do_get():
            result = self.business.get(pk)

            return self.presenter.parse(result)
        
        return self._to_try(do_get)

    def list(self, page: int, page_size: int) -> Tuple[list, int]:
        def do_list():
            payload = self.business.get_availables(page, page_size)

            data = ([self.presenter.parse(item) for item in payload['results']])

            return {
                'results': data,
                'count': payload['count'],
                'pages': payload['pages']
            }
        
        return self._to_try(do_list)
